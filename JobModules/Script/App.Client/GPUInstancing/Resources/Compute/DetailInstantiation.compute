// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols

#include "Include/Math.compute"
#include "Include/Rand.compute"
#include "Include/HeightMap.compute"
#include "Include/PerlinNoise.compute"

RWStructuredBuffer<float4x4> TransformData;
RWStructuredBuffer<float3> NormalData;
RWStructuredBuffer<float3> ColorData;
RWStructuredBuffer<uint> DividedDetailData;

RWStructuredBuffer<uint> CounterData;

// each layer in one cell
uniform float DividedDetailResolution;
uniform int2 DividedDetailIndex;
// x: minWidth | y: maxWidth | z: minHeight | w: maxHeight
uniform float4 DetailScale;
uniform int DetailLayer;
uniform float NoiseSpread;
uniform float3 HealthyColor;
uniform float3 DryColor;

// across terrain
uniform float DetailDensity;
uniform float DetailResolution;
uniform float DetailResolutionPerPatch;

[numthreads(32, 32, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) 
{
    uint index = id.x + id.y * DividedDetailResolution;
    uint indexInData = index / 2;

	uint detailCount = DividedDetailData[indexInData];
    if (indexInData * 2 == index)
        detailCount = (detailCount << 16) >> 16;
    else
        detailCount = detailCount >> 16;

	if (detailCount == 0)
		return;

    // DetailDatabase.cpp : GenerateMesh(func)
    int pixelX = DividedDetailIndex.x * DividedDetailResolution + id.x;
    int pixelY = DividedDetailIndex.y * DividedDetailResolution + id.y;

    int patchX = floor(pixelX / DetailResolutionPerPatch);
    int patchY = floor(pixelY / DetailResolutionPerPatch);
    int xInPatch = pixelX - patchX * DetailResolutionPerPatch;
    int yInPatch = pixelY - patchY * DetailResolutionPerPatch;

    int patchCount = DetailResolution / DetailResolutionPerPatch;

    int nbIndex = yInPatch * DetailResolutionPerPatch + xInPatch + DetailLayer * DetailResolutionPerPatch * DetailResolutionPerPatch;
    float nx = (patchX + xInPatch / DetailResolutionPerPatch) / patchCount;
    float ny = (patchY + yInPatch / DetailResolutionPerPatch) / patchCount;

    uint randX;
    uint randY;
    uint randZ;
    uint randW;

    RandSetSeed(nbIndex + (patchX * patchCount + patchY) * 1013, randX, randY, randZ, randW);

    if (DetailDensity < 1)
        detailCount = uint(detailCount * DetailDensity + (DitherTable[(pixelX & 7) * 8 + (pixelY & 7)] - 0.5) / 64);

    for (uint i = 0; i < detailCount; ++i)
    {
        uint index;
        InterlockedAdd(CounterData[0], 1, index);

        float normalizedX = nx + RandGetFloat(randX, randY, randZ, randW) / DetailResolution;
        float normalizedZ = ny + RandGetFloat(randX, randY, randZ, randW) / DetailResolution;

        float3 pos = float3(normalizedX * TerrainSize.x,
            GetInterpolatedHeight(normalizedX, normalizedZ),
            normalizedZ * TerrainSize.z);

        NormalData[index] = GetInterpolatedNormal(normalizedX, normalizedZ);

        float noise = PerlinNoiseNormalized(
            (BasePosition.x + pos.x) * NoiseSpread,
            (BasePosition.z + pos.z) * NoiseSpread);

        ColorData[index] = lerp(DryColor, HealthyColor, noise);

        float4 rotation = AngleAxis(Vector3Up, RandGetFloat(randX, randY, randZ, randW) * 6.2831852);

        float scaleX = lerp(DetailScale[0], DetailScale[1], noise);
        float scaleZ = lerp(DetailScale[2], DetailScale[3], noise);
        float3 scale = float3(scaleX, scaleZ, scaleX);

        pos += BasePosition;

        TransformData[index] = TRS(pos, rotation, scale);
    }
}
