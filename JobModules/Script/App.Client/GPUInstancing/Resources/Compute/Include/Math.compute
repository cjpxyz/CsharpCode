#ifndef _MATH_COMPUTE_
#define _MATH_COMPUTE_

static const float3 Vector3Up = float3(0, 1, 0);

float BilinearInterpolation(float2 uv, float leftBottom, float rightBottom, float leftUp, float rightUp)
{
	return lerp(lerp(leftBottom, rightBottom, uv.x), lerp(leftUp, rightUp, uv.x), uv.y);
}

// Returns a quaternion that represents a rotation of "angle" degrees along "axis". 
float4 AngleAxis(float3 axis, float angle)
{
    float halfAngle = angle * 0.5;
    float factor = sin(halfAngle);

    return float4(
        axis.x * factor,
        axis.y * factor,
        axis.z * factor,
        cos(halfAngle));
}

float4x4 QuaternionToMatrix(float4 q)
{
    float4x4 m;

    float x = q.x * 2;
    float y = q.y * 2;
    float z = q.z * 2;
    float xx = q.x * x;
    float yy = q.y * y;
    float zz = q.z * z;
    float xy = q.x * y;
    float xz = q.x * z;
    float yz = q.y * z;
    float wx = q.w * x;
    float wy = q.w * y;
    float wz = q.w * z;

    m._m00 = 1 - (yy + zz);
    m._m10 = xy + wz;
    m._m20 = xz - wy;
    m._m30 = 0;

    m._m01 = xy - wz;
    m._m11 = 1 - (xx + zz);
    m._m21 = yz + wx;
    m._m31 = 0;

    m._m02 = xz + wy;
    m._m12 = yz - wx;
    m._m22 = 1 - (xx + yy);
    m._m32 = 0;

    m._m03 = 0;
    m._m13 = 0;
    m._m23 = 0;
    m._m33 = 1;

    return m;
}

float4x4 TRS(float3 pos, float4 quaternion, float3 scale)
{
    float4x4 m = QuaternionToMatrix(quaternion);

    m._m00 *= scale.x;
    m._m10 *= scale.x;
    m._m20 *= scale.x;

    m._m01 *= scale.y;
    m._m11 *= scale.y;
    m._m21 *= scale.y;

    m._m02 *= scale.z;
    m._m12 *= scale.z;
    m._m22 *= scale.z;

    m._m03 = pos.x;
    m._m13 = pos.y;
    m._m23 = pos.z;

    return m;
}

#endif
