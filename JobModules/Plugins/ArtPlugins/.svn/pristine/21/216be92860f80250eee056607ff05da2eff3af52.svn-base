// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSAddTerrain
 #pragma kernel CSCulling
#pragma kernel CSUpdateCount
#include "../GpuInstance.cginc"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
 //for all
 struct GrassInfo{
 half3 position;
 half4  params;//scaleWid,scaleHei,colorLerp,Layer
 
 };
 
 //for flushrect 
 
  int terrainIndex;
    StructuredBuffer<int> density1TerrainBuffer;
   StructuredBuffer<float> heightmap1TerrainBuffer;

   RWStructuredBuffer<int> densityAllBuffer;
   RWStructuredBuffer<float> heightmapAllBuffer;
    RWTexture2D <float4> debugT2D;



  
 //for culling
  float3 rolePos;
  float3 roleDir;
 RWStructuredBuffer<int> bufferWithArgs;
 RWStructuredBuffer<GrassInfo> rectGrassBuffer;
  
 
 [numthreads(8,8,4)]
 void CSAddTerrain(uint3 id : SV_DispatchThreadID)
 {
	   
	
	int count= densityAllBuffer[id.x + id.y * 1024 + id.z * 1024 * 1024+ terrainIndex * 1024 * 1024*4]= density1TerrainBuffer[id.x + id.y * 1024 + id.z * 1024 * 1024];
	if (id.z == 0) {
		heightmapAllBuffer[terrainIndex * 1024 * 1024 + id.x + id.y * 1024] = heightmap1TerrainBuffer[id.x + id.y * 1024];
		
	}
	
 }

//[numthreads(8,8,4)]
//void CSFlushRect (uint3 id : SV_DispatchThreadID)
//{
//	// TODO: insert actual code here!
//  //if(abs(id.x-rolePos.x)>200||abs(id.y-rolePos.z)>200)return;
// 
//int count=densityBuffer[id.x+id.y*1024+id.z*1024*1024];
////printer2D[id.xy]=float4(count,0,0,1);
// 
//if(count>=1){
//for (int i=0;i<count;i++){
// 
//    int currentIndex;
//        InterlockedAdd(flushCountBuffer[0], 1, currentIndex);
//       GrassInfo info = rectGrassBuffer[currentIndex] ;
//	   
//	 float3 pos=float3(id.x*0.97656, id.x +i*100, id.y*0.97656) +terrainPosition.xyz;
//	 float rnd = rand(pos * 10+i+id.z*1000);
//	 pos.x += (rnd - 0.5) * 2;
//	 pos.z += sin(rnd*100);
//	 if (pos.x < terrainPosition.x)pos.x = terrainPosition.x;
//	 if (pos.z < terrainPosition.z)pos.z = terrainPosition.z;
//	 if (pos.x > terrainPosition.x+1000)pos.x = terrainPosition.x+ 1000;
//	 if (pos.z > terrainPosition.z+1000)pos.z = terrainPosition.z+1000;
//	 pos.y = getSampleHeight(heightmapBuffer,pos.x- terrainPosition.x, pos.z - terrainPosition.z) * 310 + terrainPosition.y;// heightmapBuffer[(int)((pos.z - terrainPosition.z)*1.024) * 1024 + (int)((pos.x - terrainPosition.x)*1.024)] * 310+terrainPosition.y;
// 	  info.position=pos;
// 	  half scaleWid=1;//(0.1-10)
// 	  half scaleHei=0.5;
//	  half colorLerp =clamp( rand(pos.xz),0.1,1);//, 0.6, 1);
//	   info.params=half4(scaleWid ,scaleHei,colorLerp , id.z);
//	   info.position.y+= scaleHei *0.5;
//	   //   info.color=float3(1,1,1);
//	  // info.layer=id.z;
//		    rectGrassBuffer[currentIndex]=info;
//}
//       
//	 }
//}
 
[numthreads(8,8,4)]
 void CSCulling(uint3 id : SV_DispatchThreadID ){
	 int wolrdX = (int)((rolePos.x + 4000)*1024/1000)+id.x - 256;
	 int wolrdZ = (int)((rolePos.z + 4000)*1024/1000)+id.y - 256;
	 int _terrainX = wolrdX / 1024;
	 int _terrainZ = wolrdZ / 1024;
	 int _terrainIndex = _terrainZ * 8 + _terrainX;
	 float3  _tpos = getTerrainPos(_terrainIndex);//terrainPositionBuffer[_terrainIndex];
	
	wolrdX %= 1024;
	wolrdZ %= 1024;
	float3 tempPos = float3(wolrdX*0.97656,0, wolrdZ*0.97656) + _tpos;
	tempPos.y = rolePos.y;
	roleDir.y = 0;
	   float rot=dot(roleDir,normalize(tempPos -rolePos));
	  if(rot<0.65)return;
	int count = densityAllBuffer[_terrainIndex*1024*1024*4+ wolrdX + wolrdZ * 1024 + id.z * 1024 * 1024];
	if (id.z == 0) {
		//debugT2D[id.xy] = float4(count /2.0, 0, 0, 1);
	}
	if (count <= 0)return;

	if (bufferWithArgs[1] > 200000)return;
 
	for (int i = 0;i < count;i++) {



		float3 pos = float3(wolrdX*0.97656, wolrdX + i * 100, wolrdZ*0.97656) + _tpos;
		float rnd = rand(pos * 10 + i + id.z * 1000);
		pos.x += (rnd - 0.5) * 2;
		pos.z += sin(rnd * 100);
		if (pos.x < _tpos.x)return;
		if (pos.z < _tpos.z)return;
		if (pos.x >= _tpos.x + 1000)return;
		if (pos.z >= _tpos.z + 1000)return;
		int currentIndex;

		InterlockedAdd(bufferWithArgs[1], 1, currentIndex);
		GrassInfo info = rectGrassBuffer[currentIndex];
		  pos.y = getSampleHeight(heightmapAllBuffer, _terrainIndex,pos.x- _tpos.x, pos.z - _tpos.z) * 310 + _tpos.y;// heightmapBuffer[(int)((pos.z - terrainPosition.z)*1.024) * 1024 + (int)((pos.x - terrainPosition.x)*1.024)] * 310+terrainPosition.y;
		// pos.y = 0;
		info.position = pos;
		half scaleWid = 1;//(0.1-10)
		half scaleHei = 0.5;
		half colorLerp = clamp(rand(pos.xz), 0.1, 1);//, 0.6, 1);
		info.params = half4(scaleWid, scaleHei, colorLerp, id.z);
		//info.position.y += scaleHei * 0.5;
		//   info.color=float3(1,1,1);
	   // info.layer=id.z;
		rectGrassBuffer[currentIndex] = info;
	}


//  int index=id.x;
//  
// GrassInfo info=rectGrassBuffer[index];
//  if(abs( rolePos.x-info.position.x)>200||abs( rolePos.z-info.position.z)>200)return;
//  float rot=dot(roleDir,normalize(info.position.xyz-rolePos));
//  if(rot<0.65)return;
//  //if(id.x%5!=1)return;
//  float dis=distance(rolePos, info.position.xyz);
// if(dis>200)return;
///*half r=rand(info.position.xz);
// if (dis > 40) {
//	 half skip = lerp(0.5, 0.9, (dis - 40)*0.00625);
//	 if (r < skip)return;
// }*/
// /*if(dis>150){
// if(r>0.5)return;
// }else if(dis>100){
// if(r>0.7)return;
// }else if(dis>60){
//
// if(r>0.8)return;
// }*/
//  int currentIndex;
//         InterlockedAdd(renderCountBuffer[0], 1, currentIndex);
//       renderIDsBuffer[currentIndex]=index;
// 	// TODO: insert actual code here!
 
 }
 [numthreads(1,1,1)]
void CSUpdateCount(uint3 id : SV_DispatchThreadID ){
 //bufferWithArgs[1]=renderCountBuffer[0]; 
}