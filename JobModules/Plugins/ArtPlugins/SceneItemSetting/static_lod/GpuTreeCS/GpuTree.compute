// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSClear
 
#define   submeshCountMax    4
struct TreeInfo {
	half3 position;
	half3  params;//scale,rot,treeIndex;
	
};
  RWStructuredBuffer<int> bufferWithArgsMulti;
  RWStructuredBuffer<int> renderIDsBuffer;
  StructuredBuffer<TreeInfo> treeLibBuffer;
  float3 rolePos;
float3 roleDir;
half4 lodDisSet;
[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
   int treeIndex=id.x;
	int currentIndex;
	TreeInfo treeInfo=	treeLibBuffer[treeIndex];
	float3 treePos= treeInfo.position;

int lod = 3;
float dis = distance(treePos.xyz, rolePos);
if (dis > lodDisSet.w)return;
half3 dir= normalize(treePos.xyz - rolePos);
roleDir.y= dir.y = 0;
 float rot = dot(roleDir, dir);
 if (rot<0.65)return;
if ( dis<lodDisSet.x) {
	lod = 0;
}
else if (dis <lodDisSet.y)
{
	lod = 1;
}
else if (dis < lodDisSet.z) {
	lod = 2;
}
lod += round(treeInfo.params.z*4 );
if (bufferWithArgsMulti[1+ lod * submeshCountMax * 5] >=4000)return;
InterlockedAdd(bufferWithArgsMulti[1 + lod*submeshCountMax  *5], 1, currentIndex);
 	   for (int i = 1; i < submeshCountMax; i++)
	   {
		   InterlockedAdd(bufferWithArgsMulti[1 + lod * submeshCountMax * 5 + 5*i], 1);//submesh 
	   }
       renderIDsBuffer[currentIndex+lod* 4000]=treeIndex;
     
}
[numthreads(8, 1, 1)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
	bufferWithArgsMulti[id.x * 5 + 1] = 0;
}